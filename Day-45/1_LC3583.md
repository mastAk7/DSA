## Solution 1: maintaining freq using vectors
### TC: O(n), SC: O(1e5) 

```cpp
// basically for any i, to check for a triplet we would need the frequency 
// of nums[i]*2
// hence we maintain two frequency arrays: f containing the total frequency
// and p containing the prefix freq or freq till the current index
// now we use pnc to choose one from all prev freq and all REMAINING freq
// nC1 = n -> hence we just multiply prev and remaining freq

// 0: special case
// nums[i]*2 for 0 would be 0 itself 
// hence the remaining freq (f[i] - p[i]) would also contain the 0 at the
// current index. hence we subtract 1 in the case of 0

const int mod = 1e9+7;
class Solution {
public:
    int specialTriplets(vector<int>& nums) {
        vector<long long> f(1e5+1,0), p(1e5+1,0);
        long long c = 0;
        for(int x:nums) f[x]++;
        for(int x:nums){
            if(x <= 50000) c += p[x*2] * (f[x*2] - p[x*2] - (x==0));
            p[x]++;
        }
        return c%mod;
    }
};
```

## Solution 2: maintaining freq using unordered map
### TC: O(nlogn) for worst case, average would be O(n), SC: O(n) 

```cpp
const int mod = 1e9+7;
class Solution {
public:
    int specialTriplets(vector<int>& nums) {
        unordered_map<int,long long> f, p;
        long long c = 0;
        for(int x:nums) f[x]++;
        for(int x:nums){
            c += p[x*2] * (f[x*2] - p[x*2] - (x==0));
            p[x]++;
        }
        return c%mod;
    }
};
```